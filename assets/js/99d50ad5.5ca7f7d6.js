"use strict";(self.webpackChunkphpvms_docs=self.webpackChunkphpvms_docs||[]).push([[2572],{2933:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"acars/plugins/aircraftconfigs","title":"Aircraft Configs","description":"Since developers often use custom offsets or datarefs, and not the defaults,","source":"@site/docs/acars/plugins/aircraftconfigs.md","sourceDirName":"acars/plugins","slug":"/acars/plugins/aircraftconfigs","permalink":"/acars/plugins/aircraftconfigs","draft":false,"unlisted":false,"editUrl":"https://github.com/phpvms/docs/tree/master/docs/acars/plugins/aircraftconfigs.md","tags":[],"version":"current","frontMatter":{"id":"aircraftconfigs","title":"Aircraft Configs"},"sidebar":"docs","previous":{"title":"Getting Started","permalink":"/acars/plugins/getting-started"},"next":{"title":"Custom Rules","permalink":"/acars/plugins/rules"}}');var t=r(4848),s=r(8453);const a={id:"aircraftconfigs",title:"Aircraft Configs"},l=void 0,o={},c=[{value:"Aircraft Configuration:",id:"aircraft-configuration",level:2},{value:"Targeting MSFS",id:"targeting-msfs",level:4},{value:"Features",id:"features",level:3},{value:"Lookup Locations",id:"lookup-locations",level:3},{value:"Equality Checking",id:"equality-checking",level:3},{value:"Ignoring Features",id:"ignoring-features",level:3},{value:"Mixed priorities",id:"mixed-priorities",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:['Since developers often use custom offsets or datarefs, and not the defaults,\nhaving configmaps allows you to map an aircraft feature (landing lights, etc) to\na "feature", which tells ACARS where to read the data for those features.\nThey\'re stored in the ',(0,t.jsx)(n.code,{children:"configmaps"})," directory."]}),"\n",(0,t.jsxs)(n.p,{children:["If you create a configmap for an aircraft, please let me know, I can include it\nin ACARS to be distributed out. That would be much appreciated! ",(0,t.jsx)(n.strong,{children:"Always create\na new file"}),", otherwise the defaults that are included with the distribution\nwill be overwritten by an updates."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"aircraft-configuration",children:"Aircraft Configuration:"}),"\n",(0,t.jsxs)(n.p,{children:["Aircraft rules are required to inherit the ",(0,t.jsx)(n.code,{children:"AircraftConfig"})," abstract class. An\nexample class would look like:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import {AircraftConfigSimType, AircraftFeature, FeatureType} from '../defs';\n// Additional mports are left out for now\n\nexport default class FenixA320 extends AircraftConfig {\n  meta: Meta = {\n    id: 'fenix_a320',\n    name: 'Fenix A320',\n    sim: AircraftConfigSimType.MsFs,\n    enabled: true,\n    priority: 2,\n  };\n\n  features: FeatureAddresses = {\n    // Aircraft feature\n    [AircraftFeature.BeaconLights]: {\n      'lvar name': FeatureType.Int,\n    },\n  };\n\n  flapNames: FlapNames = {\n    0: 'UP',\n    1: 'CONF 1',\n    2: 'CONF 1+F',\n    3: 'CONF 2',\n    4: 'CONF 3',\n    5: 'FULL',\n  };\n\n  match(title: string, icao: string, config_path: string): boolean {\n    // Check the aircraft title and return true/false if this matches\n  }\n\n  beaconLights(lvar_value: number): FeatureState {\n    // Check the lvar_value if the\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The configuration is a class which has a few different components."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"meta"}),", which gives some general information about the configuration:"]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"name"})," - a name for this script"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"sim"})," - The simulator it's for","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"AircraftConfigSimType.XPlane"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"AircraftConfigSimType.Fsuipc"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"AircraftConfigSimType.MsFs"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"AircraftConfigSimType.MsFs20"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"AircraftConfigSimType.MsFs24"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"enabled"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"priority"})," - from 1 (lowest) to 10 (highest).","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If there are multiple rules that match this, then which one takes\npriority."}),"\n",(0,t.jsx)(n.li,{children:"All the built-in rules are at a priority 1"}),"\n",(0,t.jsx)(n.li,{children:"Aircraft specifics rules are priority 2."}),"\n",(0,t.jsx)(n.li,{children:"I recommend using a priority of 3 or higher. More on this below"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"features"})," - this is the type ",(0,t.jsx)(n.code,{children:"FeatureAddresses"})," - see ",(0,t.jsx)(n.code,{children:"defs.ts"})," for the\ndefinitions"]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"MSFS - the lookups you enter are LVars"}),"\n",(0,t.jsx)(n.li,{children:"X-Plane - the looks ups are via datarefs"}),"\n",(0,t.jsx)(n.li,{children:"FSUIPC - the lookups are offsets"}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"flapNames"})," - see below"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"match()"})}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This needs to return a boolean"}),"\n",(0,t.jsxs)(n.li,{children:["A method (",(0,t.jsx)(n.code,{children:"match()"}),") which passes some information about the starting aircraft","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For MSFS, it's the aircraft ICAO"}),"\n",(0,t.jsxs)(n.li,{children:["For FSX/P3d, the value looked at is the aircraft title field, offset\n",(0,t.jsx)(n.code,{children:"0x3D00"})]}),"\n",(0,t.jsxs)(n.li,{children:["For X-Plane, the value looked at is ",(0,t.jsx)(n.code,{children:"sim/aircraft/view/acf_descrip"})]}),"\n",(0,t.jsx)(n.li,{children:"This method can be used to determine if this rule should match"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"5",children:["\n",(0,t.jsx)(n.li,{children:"Methods for the different features (see below)"}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'The maps - a group of datarefs or offsets which constitute that feature being\n"on" or "enabled"'}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:'In the above example, for the Fenix A320, the landing lights are controlled by\ntwo datarefs, both of which the values need to be 1 or 2 for the landing lights\nto be considered "on".'}),"\n",(0,t.jsx)(n.h4,{id:"targeting-msfs",children:"Targeting MSFS"}),"\n",(0,t.jsx)(n.p,{children:"There are 3 possible values for targetting MSFS in the configs:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AircraftConfigSimType.MsFs"})," - This will apply the configuration to both 2020\nand 2024"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AircraftConfigSimType.MsFs20"})," - This will be for 2020 ONLY"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AircraftConfigSimType.MsFs24"})," - This will be for 2024 ONLY"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"features",children:"Features"}),"\n",(0,t.jsxs)(n.p,{children:["Features are essentially stored in a dictionary of dictionaries, of type\n",(0,t.jsx)(n.code,{children:"FeatureAddresses"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"features: FeatureAddresses = {\n  // Aircraft feature\n  [AircraftFeature.BeaconLights]: {\n    'Lookup Address': FeatureType.Int,\n  },\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"In the above example:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AircraftFeature.BeaconLights"})," is an enum value of the feature type. It's put\nin ",(0,t.jsx)(n.code,{children:"[]"})," because it's a variable name"]}),"\n",(0,t.jsx)(n.li,{children:"It's set to an object, where the keys are the lookup address or lvar."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Lookup Address"})," is where to find this data:"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"FeatureType.Int"})," - is the type of value that's returned."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The different features available are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"beaconLights"}),"\n",(0,t.jsx)(n.li,{children:"landingLights"}),"\n",(0,t.jsx)(n.li,{children:"logoLights"}),"\n",(0,t.jsx)(n.li,{children:"navigationLights"}),"\n",(0,t.jsx)(n.li,{children:"strobeLights"}),"\n",(0,t.jsx)(n.li,{children:"taxiLights"}),"\n",(0,t.jsx)(n.li,{children:"wingLights"}),"\n",(0,t.jsx)(n.li,{children:"flaps"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The different features contain how to look up the value, and the type. You can\nhave multiple variables to be read and looked at for a feature. Each feature\nthen corresponds to a method which is called to return if that feature is on or\noff. That method will have the equivalent number of arguments for each data\nreference"}),"\n",(0,t.jsx)(n.h3,{id:"lookup-locations",children:"Lookup Locations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For FSUIPC, the lookup location is the offset"}),"\n",(0,t.jsx)(n.li,{children:"For X-Plane, it's the DRef"}),"\n",(0,t.jsxs)(n.li,{children:["For MSFS, it's either the LVar name, or a Simvar:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Simvar has to be prefixed with ",(0,t.jsx)(n.code,{children:"A:"}),", e.g, ",(0,t.jsx)(n.code,{children:"A:LIGHT LOGO,bool"}),", and then the\ntype"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Examples:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export default class Example extends AircraftConfig {\n  features: FeatureAddresses = {\n    // FSUIPC Offset Example:\n    [AircraftFeature.NavigationLights]: {\n      '0x0D0C': FeatureType.Int,\n    },\n\n    // MSFS LVar Example:\n    [AircraftFeature.LogoLights]: {\n      switch_116_a: FeatureType.Int,\n    },\n\n    // MSFS Simvar Example:\n    [AircraftFeature.StrobeLights]: {\n      'A:LIGHT STROBE,bool': FeatureType.Bool,\n    },\n\n    // X-Plane Example\n    [AircraftFeature.BeaconLights]: {\n      'sample/dataref/1': FeatureType.Bool,\n      'sample/dataref/2': FeatureType.Bool,\n    },\n  };\n\n  /**\n   * An example of a method to check the beacon lights\n   *\n   * @param {boolean} The value of /sample/dataref_1\n   * @param {boolean} The value of /sample/dataref_2\n   * @returns {FeatureState}\n   */\n  beaconLights(dataref_1: boolean, dataref_2: boolean): FeatureState {\n    if (dataref_1 && dataref_2) {\n      return true;\n    }\n\n    return false;\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"equality-checking",children:"Equality Checking"}),"\n",(0,t.jsxs)(n.p,{children:["I recommend using ",(0,t.jsx)(n.code,{children:"=="})," instead of ",(0,t.jsx)(n.code,{children:"==="})," for equality comparisons, since the\ntypes coming from the sim may not always match up or be cast properly (e.g, ",(0,t.jsx)(n.code,{children:"1"}),"\nbeing returned instead of ",(0,t.jsx)(n.code,{children:"true"}),")"]}),"\n",(0,t.jsx)(n.h3,{id:"ignoring-features",children:"Ignoring Features"}),"\n",(0,t.jsx)(n.p,{children:"To ignore a feature in the rules (for example, if a feature doesn't work\nproperly), set the feature to false:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import {AircraftFeature} from './defs';\n\nfeatures: FeatureAddresses = {\n  // Aircraft feature\n  [AircraftFeature.BeaconLights]: {\n    'lvar name': FeatureType.Int,\n  },\n  [AircraftFeature.LandingLights]: false,\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mixed-priorities",children:"Mixed priorities"}),"\n",(0,t.jsx)(n.p,{children:"If there are two scripts which match a particular aircraft, and a feature is\nomitted, it will use the lower priority one in place. For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import {FeatureAddresses} from './aircraft';\n\nexport default class Example extends AircraftConfig {\n  meta: Meta = {\n    // ...\n    priority: 1,\n  };\n\n  features: FeatureAddresses = {\n    [AircraftFeature.BeaconLights]: {\n      'sample/dataref/1': FeatureType.Bool,\n      'sample/dataref/2': FeatureType.Bool,\n    },\n    [AircraftFeature.LandingLights]: {\n      'sample/landing/light/1': FeatureType.Bool,\n      'sample/landing/light/2': FeatureType.Bool,\n    },\n  };\n}\n\nexport default class ExampleOverride {\n  meta: Meta = {\n    // ...\n    priority: 10,\n  };\n\n  features: FeatureAddresses = {\n    [AircraftFeature.LandingLights]: {\n      'override/landing/light/1': FeatureType.Bool,\n      'override/landing/light/2': FeatureType.Bool,\n    },\n  };\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this case, the lookups used for the rules will be:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["beaconLights - ",(0,t.jsx)(n.code,{children:"sample/dataref/1|2"})]}),"\n",(0,t.jsxs)(n.li,{children:["landingLights - ",(0,t.jsx)(n.code,{children:"override/landing/light/1|2"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var i=r(6540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);